#!/bin/bash

# radio - Bash shell script for listening radio basically

# Copyright 2020, Taeseong Ryu <formeu2s@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANT-ABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License at <http://www.gnu.org/licenses/> for
# more details.



### description:
#
# play music from various sources such as radio, youtube and local storage
#

# HTTP Error 429: Too Many Requests
# workaround:
# extract cookies from browser (extension: cookies.txt)
# add --cookies /path/to/cookies/file.txt in youtube-dl config file
#



### TODO
#
# curl, google code
# completion suggest for zsh
# visit the web-page played by youtube_search's result
# how to kill all radio with C-c
#



shopt -s globstar # Allow ** for recursive matches
set -u # avoid a undeclared variable
# set -x # for debugging
g_arg=( "$@" )
g_arg0="$0"
SCRIPT_VERSION=0.2.0
PS3='
# 00 for all
choose : '
if [[ ${g_arg[0]} == --sound_only ]]; then
    g_arg=( "${g_arg[@]:1}" )
    PLAYER='mpv --vo=null' # sound only
else
    PLAYER=mpv
fi
LOCAL_VIDEO_DIR=/mnt/data/Videos/
LOCAL_MUSIC_DIR=/mnt/data/Music/
LOCAL_MUSIC_EXT='\.(mp3|flac)$'
SCRIPT_PATH=$(realpath "$g_arg0") # test
SCRIPT_DIR="${SCRIPT_PATH%/*}"
SCRIPT_NAME="${SCRIPT_PATH##*/}"
LISTS_DIR="$SCRIPT_DIR"/lists/
COMPLETIONS_DIR="$SCRIPT_DIR"/completions/
ARR_YOUTUBE_RESULT="$LISTS_DIR"/arr_youtube_result
ENGLISH_RADIO_PATH="$LISTS_DIR"/english_radio
KOREAN_RADIO_PATH="$LISTS_DIR"/korean_radio
JAPANESE_RADIO_PATH="$LISTS_DIR"/japanese_radio
LIVE_CAMERA_PATH="$LISTS_DIR"/live_camera
LIVE_NEWS_PATH="$LISTS_DIR"/live_news
LIVE_TV_PATH="$LISTS_DIR"/live_tv
LOCAL_MUSIC_PATH="$LISTS_DIR"/local_music
MUSIC_VIDEO_PATH="$LISTS_DIR"/music_video
PLAY_LIST_PATH="$LISTS_DIR"/play_list
XXX_PATH="$LISTS_DIR"/xxx # no public
#
# last line need ^$ for cat
#
RADIO_LIST=$(cat "$ENGLISH_RADIO_PATH" \
                 "$KOREAN_RADIO_PATH" \
                 "$JAPANESE_RADIO_PATH")
LIVE_LIST=$(cat "$LIVE_CAMERA_PATH" \
                "$LIVE_NEWS_PATH" \
                "$LIVE_TV_PATH")
URL_LIST=$(cat "$ENGLISH_RADIO_PATH" \
               "$KOREAN_RADIO_PATH" \
               "$JAPANESE_RADIO_PATH" \
               "$LIVE_CAMERA_PATH" \
               "$LIVE_NEWS_PATH" \
               "$LIVE_TV_PATH" \
               "$MUSIC_VIDEO_PATH" \
               "$PLAY_LIST_PATH" \
               "$XXX_PATH")
NOTSODEEP_PATH="$HOME"/git/notsodeep/notsodeep
YT_PREFIX='https://www.youtube.com/watch?v='
BASH_COMPLETION_PATH="$COMPLETIONS_DIR"/radio-completion.bash
ZSH_COMPLETION_PATH="$COMPLETIONS_DIR"/radio-completion.zsh
REPORT_PATH="$SCRIPT_DIR"/report
REPORT_START_LINE='### ERROR REPORT'
TEST_TIME=10 # secs
DUMP_RETRY_AFTER=1 # youtube-dl --json-dump
DUMP_SUCCESS_SOUND_PATH=/mnt/data/Sound/Alert.mp3
#
# basic regex escape ‘\?’, ‘\+’, ‘\|’, ‘\{’, '\}', ‘\(’, and ‘\)’
#
SKIP_PATTERN='^#\?$\|^##\+\|^#[^ ]\|^#  \+'
#
# error code
#
E_IN_A_ROW=64
E_NO_MATCH_REGEX=65
E_FAIL_DUMP_YOUTUBE=66
E_NOT_SYNC_PROPERTIES=67
E_NO_PARAM=99
#
# color code
#
C_='\e[0m'
for i in {0..255}; do
    declare -n X=C_$i # declare -n, eval, export
    X="\e[1;38;5;${i}m" # 256 foreground color format
done
i=0
C_ERROR=$C_1
C_WARN=$C_128
C_FAIL=$C_124
C_SUCCESS=$C_98
C_LIST_TITLE=$C_117
C_LIST_BODY=$C_240
C_LIST_NUMBER=$C_40
C_TITLE=$C_130
C_INFO_TITLE=$C_220
C_INFO_BODY=$C_142
C_INFO_NUMBER=$C_40
C_DESCRIPTION=$C_144



display_color_code() {
    #
    # TODO: add bg
    #
    local max_length=0
    local i k
    color_codes=( C_ERROR       C_WARN        C_FAIL
                  C_SUCCESS     C_LIST_TITLE  C_LIST_BODY
                  C_LIST_NUMBER C_TITLE       C_INFO_TITLE
                  C_INFO_BODY   C_INFO_NUMBER C_DESCRIPTION )
    printf '\n'
    for i in ${!color_codes[@]}; do
        if (( ${#color_codes[i]} > max_length )); then
            max_length=${#color_codes[i]}
        fi
    done
    for k in "${color_codes[@]}"; do
        declare -n X=$k
        printf "$X%-${max_length}s :  %3s\n" \
               $k \
               $(sed 's/.*;\([0-9]\+\)m$/\1/' <<< $X)
    done
    printf "${C_}"
    printf '\n'
}

display_256color_code_v() {
    local FB c
    printf '\n'
    for FB in {3,4}; do
        for c in {0..255}; do
            printf "\e[${FB}8;5;%sm %3s ${C_}" \
                   $c \
                   $c
            (( c%6 == 3 )) && printf '\n'
        done
        printf '\n'
    done
    printf '\n'
    exit 0
}

display_256color_code_h() {
    local split_width=10
    local i=0
    local start_color
    local c
    printf '\n'
    for c in {0..255}; do
        ((i++))
        printf "\e[38;5;%sm %3s ${C_}" $c $c
        if (( c%6 == 3 )); then
            if (( i == 4 )); then
                start_color=$((c-3))
                printf '%*s' $((split_width+10))
            else
                start_color=$((c-5))
                printf '%*s' $split_width
            fi
            for c in $(eval echo {$start_color..$c}); do
                printf "\e[7;38;5;%sm %3s ${C_}" $c $c
            done
            printf '\n'
            i=0
        fi
    done
    printf '\n'
    exit 0
}

display_256color_code() {
    local split_width=10
    local start_color sub_color add_width
    local c
    printf '\n'
    for c in {0..255}; do
        printf "\e[1;38;5;%sm %3s ${C_}" $c $c
        if (( c%6 == 3 )); then
            start_color=$((c-${sub_color:-3}))
            printf '%*s' $((split_width+${add_width:-10}))
            sub_color=5
            add_width=0
            for c in $(eval echo {$start_color..$c}); do
                printf "\e[7;38;5;%sm %3s ${C_}" $c $c
            done
            printf '\n'
        fi
    done
    printf '\n'
    exit 0
}

back_trace() {
    # local max_length
    local caller_line caller_funcname caller_frame caller_result
    local max_line max_funcname max_frame
    local i=0
    local k
    # for k in ${!FUNCNAME[@]}; do
    #     if (( ${#FUNCNAME[k]} > ${max_length:-0} )); then
    #         max_length=${#FUNCNAME[k]}
    #     fi
    # done
    # printf "\n %${max_length}s | %-5d" \
    #      LINENO $LINENO
    # for k in ${!BASH_LINENO[@]}; do
    #     printf "\n %${max_length}s | %-5d" \
    #            ${FUNCNAME[k]} \
    #            ${BASH_LINENO[k]}
    # done
    while true ; do
        caller_result=$(caller $i)
        [[ -z $caller_result ]] && break
        arr_caller_funcname+=( $(cut -d ' ' -f 2 <<< $caller_result) )
        arr_caller_line+=( $(cut -d ' ' -f 1 <<< $caller_result) )
        arr_caller_frame+=( $(cut -d ' ' -f 3 <<< $caller_result) )
        ((i++))
    done
    for k in ${!arr_caller_funcname[@]}; do
        if (( ${#arr_caller_funcname[k]} > ${max_funcname:-0} )); then
            max_funcname=${#arr_caller_funcname[k]}
            #                                   ^
            # can remove $ for index
            #
        fi
    done
    for k in ${!arr_caller_line[@]}; do
        if (( ${#arr_caller_line[k]} > ${max_line:-0} )); then
            max_line=${#arr_caller_line[k]}
        fi
    done
    for k in ${!arr_caller_frame[@]}; do
        if (( ${#arr_caller_frame[k]} > ${max_frame:-0} )); then
            max_frame=${#arr_caller_frame[k]}
        fi
    done
    for k in ${!arr_caller_frame[@]}; do
        printf "%${max_funcname}s | %-${max_line}s | %-${max_frame}s\n" \
               ${arr_caller_funcname[k]} \
               ${arr_caller_line[k]} \
               ${arr_caller_frame[k]}
    done
    printf '\n'
}

test_print() {
    local arg1="$1"
    local -n arg2="$1" # name reference
    local items_number=0
    local p1="\n${C_40}%s list %s${C_}\n"
    local p2="\n${C_40}%s lists %s${C_}\n"
    local p3="\n${C_220}%s | %s | %s\n${C_240}%s${C_}"
    local caller_result=$(caller 0)
    local caller_line=$(cut -d ' ' -f 1 <<< $caller_result)
    local caller_funcname=$(cut -d ' ' -f 2 <<< $caller_result)
    local caller_frame=$(cut -d ' ' -f 3 <<< $caller_result)
    printf "$p3" \
           "${caller_funcname}()'s $arg1" \
           "$caller_line" \
           "$caller_frame" \
           "$arg2"
    [[ -n $arg2 ]] && items_number=$(wc -l <<< $arg2)
    if (( items_number == 1 )); then
        printf "$p1" $items_number
    elif (( items_number > 1 )); then
        printf "$p2" $items_number
    else
        printf "$p1" no
    fi
    return 0
}

print_shuffle_list() {
    local arg1="$1"
    local p1="\n${C_220}%s${C_}"
    local p2="\n${C_240}%s${C_}\n"
    local p3="\n${C_196}%s${C_}\n\n"
    local p4="${C_24}%s${C_}"
    local p5="${C_25}%s${C_}"
    local p6="${C_26}%s${C_}"
    local p7="${C_27}%s${C_}"
    local items_number=0
    printf "$p1" shuffle_list
    printf "$p2" \
           "$(printf %b "$arg1" | sed 's/\\"/"/g')"
    #      ^            ^     ^                   ^
    # need " " for printf output and arg1
    #
    [[ -n $arg1 ]] && items_number=$(wc -l <<< $arg1)
    if (( n_init_shuffle_list == 0 )); then
        printf "$p7" 'no list'
    elif (( n_init_shuffle_list == 1 )); then
        printf "$p7" '1 list'
    elif (( items_number == 1 )); then
        printf "${p7}${p6}${p5} ${p4}\n" \
               $items_number \
               '/' \
               $n_init_shuffle_list \
               'list'
    elif (( items_number > 1 )); then
        printf "${p7}${p6}${p5} ${p4}\n" \
               $items_number \
               '/' \
               $n_init_shuffle_list \
               'lists'
    else
        printf "$p3" ' Something is wrong!'
        back_trace
        exit 1
    fi
    return 0
}

playing_youtube_print() {
    local arg0=( "$@" )
    local arg1="$1"
    local arg2="$2"
    local arg3="$3"
    local arg4="$4"
    local arg5="${5:-0}"
    local arg6="$6"
    local arg7="$7"
    local arg8="$8"
    local p1="\n${C_130}%s${C_}\n"
    local p2="\n${C_142}%s | %s | %s | %.2f | %s\n%s${C_}\n"
    local p3="\n${C_144}%s${C_}\n\n"
    local IGNORE_DESCRIPTION_CHARS=3
    local DISPLAY_DESCRIPTION_LINES=10
    local DISPLAY_DESCRIPTION_CHARS=500
    local arg3_h arg3_m arg3_s arg8_wc_w arg8_wc_l
    local line_wc_c
    local total=0
    local max_char=0
    local line
    arg1=$(printf %b "$arg1" | sed 's/\\"/"/g') # title
    arg2=$(date -d $arg2 +%Y/%m/%d) # date
    if (( arg3 )); then # duration
        # ^
        # can remove $ in ((  ))
        #
        arg3_h=$((arg3/3600))
        arg3_m=$((arg3/60%60))
        arg3_s=$((arg3%60))
        if (( arg3_h )); then
            arg3=$(printf "%02d:%02d:%02d" \
                          $arg3_h \
                          $arg3_m \
                          $arg3_s)
        else
            arg3=$(printf "%02d:%02d" \
                          $arg3_m \
                          $arg3_s)
        fi
    else
        arg3=LIVE
    fi
    #
    # k, M, G, T, P, E, Z, Y
    # k, M, B, T, Q, Q, S, S
    #
    arg4=$(numfmt --to=si $arg4 | sed 's/G/B/')
    arg5=$(echo "$arg5 * 20" | bc) # rating
    arg6=$(printf %b "$arg6") # uploader
    arg8=$(printf %b "$arg8" | sed 's/\\"/"/g') # description
    #                                 ^^    ^
    # need \\ for literally '\'
    #
    # g for all occurrence
    #
    printf "$p1" \
           "$arg1"
    printf "$p2" \
           "$arg2" \
           "$arg3" \
           "$arg4" \
           $arg5 \
           "$arg6" \
           "$arg7"
    #
    # remove too short or too long description
    #
    # only 1 line can be too long
    #
    arg8_wc_c=$(wc -c <<< $arg8) # 500
    arg8_wc_l=$(wc -l <<< $arg8) # 10
    readarray -t arr_arg8 <<< $arg8
    for line in "${arr_arg8[@]}"; do
        line_wc_c=$(wc -c <<< $line)
        if (( line_wc_c > max_char )); then
            max_char=$line_wc_c
        fi
    done
    if (( arg8_wc_c > IGNORE_DESCRIPTION_CHARS )); then # too short description
        if (( max_char > 120 )); then # a long line
            arg8= # need null string
            for line in "${arr_arg8[@]}"; do
                line_wc_c=$(wc -c <<< $line)
                total=$((total+line_wc_c))
                # printf "line0 is $line\n"
                # printf "total0 is $total\n"
                arg8+="${line:+$'\n'}$line" # this line's position matters
                if (( total > DISPLAY_DESCRIPTION_CHARS )); then
                    # printf "total is $total\n"
                    # printf "line is $(wc -l <<< $arg8)/${#arr_arg8[@]}"
                    arg8+=' ,,,'
                    break
                fi
            done
        elif (( arg8_wc_l > DISPLAY_DESCRIPTION_LINES )); then # too many lines
            arg8=$(head -n 10 <<< $arg8)
            arg8+=' ,,,'
        fi
        printf "$p3" \
               "$arg8"
    fi
    return 0
}

playing_print() {
    local arg1="$1"
    local p1="\n${C_130} %s${C_}\n\n"
    # test_print arg1
    if [[ $arg1 =~ (.*)[[:space:]]https?:// ]]; then
        # printf "$p1" "$(sed 's/http.*//' <<< $arg1)"
        printf "$p1" "${BASH_REMATCH[1]}" # test
    elif [[ $arg1 =~ /$ ]]; then
        printf "$p1" "$arg1"
    elif [[ $arg1 =~ (.*)[[:space:]]/mnt/ ]]; then
        # printf "$p1" "$(sed 's!/mnt/.*!!' <<< $arg1)"
        printf "$p1" "${BASH_REMATCH[1]}"
    else
        printf "$p1" "$arg1"
    fi
    return 0
}

make_namelist() {
    #
    # grep 'and' option
    #
    local arg1="$1"
    local reverse=
    local name_part names_part
    local line value
    declare -g input_lines=
    #                      ^
    # need null string
    #
    local input_line names_part_lines
    if [[ -n ${REPLY:-} ]]; then
        #
        # need ${REPLY/ /$'\n'}
        #
        # equivalent:
        # oIFS="$IFS"; IFS=' '; ... <<< $REPLY ; IFS="$oIFS"
        #
        readarray -t arr_namelist <<< ${REPLY/ /$'\n'}
    else
        arr_namelist=( "${g_arg[@]}" )
        #              ^           ^
        # need " " such as 'lsd sia'
        #
    fi
    readarray -t arr_arg1 <<< $arg1
    for line in "${arr_arg1[@]}"; do # duplicated, to function
        if [[ ${FUNCNAME[@]} =~ youtube_search ]]; then
            name_part=$(sed 's/"title": "//' <<< $line \
                                  | sed 's/" "upload_date": ".*//')
        elif [[ $line =~ [[:space:]]https?:// ]]; then
            name_part=$(sed 's/ http.*//' <<< $line)
        elif [[ $line =~ ^/mnt/ ]]; then
            name_part=$(sed 's!.*/Music/!!'<<< $line)
        elif [[ $line =~ [[:space:]]/mnt/ ]]; then
            name_part=$(sed 's!/mnt/.*!!' <<< $line)
        else
            name_part="$line"
        fi
        names_part+=${names_part:+$'\n'}"$name_part"
    done
    # test_print names_part
    for value in "${arr_namelist[@]}"; do
        if [[ -z ${names_part_lines:-} ]]; then
            # test_print value
            [[ $value =~ ^-+[a-z]+ ]] && continue
            names_part_lines=$(grep -i "$value" <<< $names_part)
        else
            # test_print value
            if [[ $value == -v ]]; then
                reverse=v
                continue
            fi
            names_part_lines=$(grep -i$reverse "$value" <<< $names_part_lines)
            [[ -n $reverse ]] && reverse=
        fi
    done
    # test_print names_part_lines
    if [[ -z $names_part_lines ]]; then
        printf "\n${C_88}%s${C_240}%s${C_88}%s\n${C_}" \
               '@@@' \
               " error occurred | ${FUNCNAME[0]} | $LINENO " \
               '@@@'
        printf "\n ${C_88}%s${C_}\n\n" \
               "No match with '${arr_namelist[@]}'"
        exit $E_NO_MATCH_REGEX
    fi
    readarray -t arr_names_part_lines <<< $names_part_lines
    for line in "${arr_names_part_lines[@]}"; do
        input_line=$(grep -i "$line" <<< $arg1)
        input_lines+=${input_lines:+$'\n'}"$input_line"
    done
    # test_print input_lines
    return 0
}

make_shuffle_list() {
    local arg1="$1"
    local print_name print_names
    local line
    arg1=$(sed 's/^# //' <<< $arg1)
    readarray -t arr_arg1 <<< $arg1
    for line in "${arr_arg1[@]}"; do
        if [[ ${FUNCNAME[@]} =~ youtube_search ]]; then
            print_name=$(sed 's/"title": "//' <<< $line \
                                  | sed 's/" "upload_date": ".*//')
        elif [[ $line =~ [[:space:]]https?:// ]]; then
            print_name=$(sed 's/ http.*//' <<< $line)
        elif [[ $line =~ ^/mnt/ ]]; then
            print_name=$(sed 's!.*/Music/!!'<<< $line)
        elif [[ $line =~ [[:space:]]/mnt/ ]]; then
            print_name=$(sed 's!/mnt/.*!!' <<< $line)
        else
            print_name="$line"
        fi
        print_names+=${print_names:+$'\n'}"$print_name"
    done
    print_shuffle_list "$print_names"
    return 0
}

shuffle_list() {
    #
    # all items must be selected only once for one-cycle
    #
    # uses shuf
    #
    local arg1="$1"
    local firstshuffle
    declare -g shuffle_list n_init_shuffle_list shuffle_radio last_shuffle
    # test_print arg1
    [[ -z $arg1 ]] && exit $E_NO_PARAM
    if [[ -z ${shuffle_list:-} ]]; then
        n_init_shuffle_list=$(wc -l <<< $arg1)
        first_shuffle=$(shuf -n 1 <<< $arg1)
        #
        # avoid selecting the same item in a row
        #
        if [[ $first_shuffle == ${last_shuffle:-} ]]; then
            printf "\n ${C_88}%s${C_}\n\n" \
                   reshuffling ...
            return $E_IN_A_ROW
        else
            make_shuffle_list "$arg1"
            shuffle_list=$(grep -vF "$first_shuffle" <<< $arg1)
            #                     ^
            # need -F
            #
            shuffle_radio="$first_shuffle"
        fi
    else
        make_shuffle_list "$shuffle_list"
        last_shuffle=$(shuf -n 1 <<< $shuffle_list)
        shuffle_list=$(grep -vF "$last_shuffle" <<< $shuffle_list)
        shuffle_radio="$last_shuffle"
    fi
    # eval "$2=\$arg2" # for returning a string
    return 0
}

play_youtube() {
    local arg1="$1"
    local p_title p_date p_average_rating p_view_count
    local p_duration p_uploader p_webpage_url p_description
    local s1
    #
    # s1 is something wrong
    #
    # s1=$(printf '%s%s%s%s%s%s%s%s' \
    #             '"title": "\(.*\)" ' \
    #             '"upload_date": "\([0-9]\{8\}\)" ' \
    #             '"duration": \([0-9]\+\) ' \
    #             '"view_count": \([0-9]\+\) ' \
    #             '"average_rating": \([0-9.]\+\) ' \
    #             '"uploader": "\(.*\)" ' \
    #             '"webpage_url": "\(.*\)" ' \
    #             '"description": "\(.*\)"')
    # p_title=$(sed "s/$s1/\1/" <<< $arg1)
    # p_date=$(sed "s/$s1/\2/" <<< $arg1)
    # p_duration=$(sed "s/$s1/\3/" <<< $arg1)
    # p_view_count=$(sed "s/$s1/\4/" <<< $arg1)
    # p_average_rating=$(sed "s/$s1/\5/" <<< $arg1)
    # p_uploader=$(sed "s/$s1/\6/" <<< $arg1)
    # p_webpage_url=$(sed "s/$s1/\7/" <<< $arg1)
    # p_description=$(sed "s/$s1/\8/" <<< $arg1)
    p_title=$(sed 's/"title": "//' <<< $arg1 \
                  | sed 's/" "upload_date":.*//')
    p_date=$(sed 's/.*"upload_date": "//' <<< $arg1 \
                 | sed 's/" "duration":.*//')
    p_duration=$(sed 's/.*"duration": //' <<< $arg1 \
                     | sed 's/ "view_count":.*//')
    p_view_count=$(sed 's/.*"view_count": //' <<< $arg1 \
                       | sed 's/ "average_rating":.*//')
    p_average_rating=$(sed 's/.*"average_rating": //' <<< $arg1 \
                           | sed 's/ "uploader":.*//')
    p_uploader=$(sed 's/.*"uploader": "//' <<< $arg1 \
                     | sed 's/" "webpage_url":.*//')
    p_webpage_url=$(sed 's/.*"webpage_url": "//' <<< $arg1 \
                        | sed 's/" "description":.*//')
    p_description=$(sed 's/.*"description": "//' <<< $arg1 \
                        | sed 's/"//')
    playing_youtube_print "$p_title" \
                          $p_date \
                          $p_duration \
                          $p_view_count \
                          $p_average_rating \
                          "$p_uploader" \
                          "$p_webpage_url" \
                          "$p_description"
    #
    # in mpv.conf
    #
    # no     complete silence
    # fatal  fatal messages only
    # error  error messages
    # warn   warning messages
    # info   informational messages
    # status status messages (default)
    # v      verbose messages
    # debug  debug messages
    # trace  very noisy debug messages
    #
    # msg-level=all=error
    #
    # or
    #
    # 1>/dev/null disable information
    # 2>/dev/null disable process-bar
    # &>/dev/null disable all and can not control
    #
    $PLAYER "$p_webpage_url" 2>/dev/null
    return 0
}

play() {
    local arg1="$1"
    local execute_part name_part head_part option_part
    local p1="\n ${C_88}%s${C_}\n\n" \
    # test_print arg1
    arg1=$(sed 's/^# / /' <<< $arg1)
    if [[ $arg1 =~ [[:space:]]https?:// ]]; then
        name_part=$(sed 's! https\?://.*!!' <<< $arg1)
    elif [[ $arg1 =~ /$ ]]; then
        name_part="$arg1"
    elif [[ $arg1 =~ ^/mnt/ ]]; then
        name_part=$(sed 's!.*/Music/!!g' <<< $arg1)
    elif [[ $arg1 =~ [[:space:]]/mnt/ ]]; then
        name_part=$(sed 's! /mnt/.*!!' <<< $arg1)
    else
        printf "$p1" \
               'Something is wrong!'
        back_trace
        exit 1
    fi
    # test_print name_part
    if [[ $arg1 =~ [[:space:]]https?:// ]]; then
        execute_part=${arg1/*http/http}
    elif [[ $arg1 =~ /$ ]]; then
        execute_part="$LOCAL_MUSIC_DIR""$arg1"
    elif [[ $arg1 =~ ^/mnt/ ]]; then
        execute_part="$arg1"
    elif [[ $arg1 =~ [[:space:]]/mnt/ ]]; then
        execute_part=${arg1/*mnt//mnt}
    else
        printf "$p1" \
               'Something is wrong!'
        back_trace
        exit 1
    fi
    #test_print execute_part
    playing_print "$name_part"

    if [[ $execute_part =~ [[:space:]]--[a-z]+ ]]; then
        head_part=${execute_part%% --*}
        #                         ^
        # need space for trailing
        #
        option_part=${execute_part#"$head_part" }
        #                          ^          ^^
        # need quotes and space
        #
        # test_print head_part
        # test_print option_part
        $PLAYER "$head_part" $option_part
        #                   ^            ^
        # don't quote options
        #
    else
        $PLAYER "$execute_part"
    fi
    return 0
}

play_radio() {
    while true; do
        radio_list=$(grep -v "$SKIP_PATTERN" <<< $RADIO_LIST)
        shuffle_list "$radio_list"
        (( $? == E_IN_A_ROW )) && continue
        play "$shuffle_radio"
        sleep 0.1 # needed for C-c
    done
    return 0
}

show_all(){
    radio ..
    #     ^^
    # one . increases x3 items
    return 0
}

play_group() {
    local group_list
    # test_print URL_LIST
    case ${g_arg[1]} in
        en | english    ) group_list=$(<"$ENGLISH_RADIO_PATH");;
        kr | korean     ) group_list=$(<"$KOREAN_RADIO_PATH");;
        jp | japanese   ) group_list=$(<"$JAPANESE_RADIO_PATH");;
        mv | musicvideo ) group_list=$(<"$MUSIC_VIDEO_PATH");;
        lt | livetv     ) group_list=$(<"$LIVE_TV_PATH");;
        ln | livenews   ) group_list=$(<"$LIVE_NEWS_PATH");;
        lc | livecam    ) group_list=$(<"$LIVE_CAMERA_PATH");;
        pl | playlist   ) group_list=$(<"$PLAY_LIST_PATH");;
        *)
            printf "\n %s${C_88} %s${C_} %s\n" \
                   'There is no' \
                   "'${g_arg[1]}'" \
                   'group.'
            cat <<EOF

 Usage : radio -g option

 Option: en - English Radio
         kr - Korean Radio
         jp - Japanese Radio
         mv - Music Video
         lt - Live TV
         ln - Live News
         lc - Live Camera
         pl - Play List

EOF
            # back_trace
            exit 2
            ;;
    esac
    while true; do
        group_list=$(grep -v "$SKIP_PATTERN" <<< $group_list)
        shuffle_list "$group_list"
        (( $? == E_IN_A_ROW )) && continue
        play "$shuffle_radio"
        sleep 0.1 # needed for C-c
    done
    return 0
}

select_one_input_line() {
    local names_count=$(wc -l <<< $input_lines)
    if (( names_count > 1 )); then
        select_list "$arg1" "$input_lines" # select_list's arg1
    fi
    return 0
}

select_play() {
    local shuffle_line
    # test_print arg1 # arg1 is select_list()'s
    while true; do
        shuffle_list "$input_lines"
        (( $? == E_IN_A_ROW )) && continue
        # test_print shuffle_radio
        shuffle_line=$(grep -iF "$shuffle_radio" <<< $arg1)
        if [[ ${FUNCNAME[@]} =~ youtube_search ]]; then
            play_youtube "$shuffle_line" # need
        else
            play "$shuffle_line"
        fi
        sleep 0.1 # needed for C-c
    done
    return 0
}

select_all() {
    printf '\n %s\n' \
           'You chose all items.'
    select_play
    return 0
}

select_sed() {
    local sed_reply
    printf '\n %s\n' \
           'You selected multiple items with - and numbers.'
    #
    # transform for sed
    #  3-5 7 11 15-20         --> 3,5p;7p;11p;15,20p
    #    3     -5  7  8-   9  --> 3,5p;7p;8,9p
    #   -  2     6  -         --> 1,2p;6,{endline}p
    #
    sed_reply=$(sed 's/^ \+\| \+$//g' <<< $REPLY \
                | sed 's/ \+/ /g' \
                | sed 's/ -\|- /-/g' \
                | sed 's/ /p;/g' \
                | sed 's/-/,/g' \
                | sed 's/^,/1,/' \
                | sed "s/,$/,$grepcount/" \
                | sed 's/$/p/')
    # test_print REPLY
    input_lines=$(sed -n "$sed_reply" <<< $input_lines)
    select_one_input_line
    select_play
    return 0
}

select_regex() {
    printf '\n %s\n' \
           'You selected items with regex.'
    make_namelist "$input_lines"
    # test_print input_lines
    select_one_input_line
    select_play
    return 0
}

select_list() {
    local arg1="$1"
    local arg2="$2"
    local r1='[0-9]*[-\ ]+[0-9]*'
    local r2='[^0-9\ -]+'
    local p1="\n ${C_88}%s${C_}\n\n"
    local s1
    local input_name_part
    # test_print arg2
    grepcount=$(grep -ic .  <<< $input_lines)
    if (( grepcount == 1 )); then
        grep_line=$(grep -iF "$arg2" <<< $arg1)
        #                  ^
        # grep '-F' for only string, such as "[live] tv"
        #                                     ^    ^
        play "$grep_line"
        sleep 0.1 # needed for C-c
    elif (( grepcount > 1 )); then
        if [[ ${FUNCNAME[@]} =~ youtube_search ]]; then
            input_name_part=$(sed 's/"title": "//' <<< $arg2 \
                                  | sed 's/" "upload_date":.*//' \
                                  | sed 's/\\n/ /g')
            #                              ^^^
            # "title" "도시의 그림자 -\n이 어둠의 이슬픔"
            #                      ^^
            # in select(), added one more line
            #
            # test_print input_name_part
        elif [[ $arg2 =~ [[:space:]]https?:// ]]; then
            input_name_part=$(sed 's! https\?://.*!!' <<< $arg2)
        elif [[ $arg2 =~ ^/mnt/ ]]; then
            input_name_part=$(sed 's!.*/Music/!!g' <<< $arg2)
        elif [[ $arg2 =~ [[:space:]]/mnt/ ]]; then
            input_name_part=$(sed 's! /mnt/.*!!' <<< $arg2)
        elif [[ $arg2 =~ /$ ]]; then
            input_name_part="$arg2"
        else
            printf "$p1" \
                   'Something is wrong!'
            back_trace
            exit 1
        fi
        input_name_part=$(printf %b "$input_name_part" \
                                  | sed 's/\\"/"/g') # Unicode-to-utf8
        # test_print input_name_part
        readarray -t arr_names <<< $input_name_part
        printf '\n' # needed
        select line in "${arr_names[@]}"; do
            if [[ $REPLY =~ ^00$ ]]; then
                select_all
                exit 0
            elif [[ $REPLY =~ $r1 && ! $REPLY =~ $r2 ]]; then
                select_sed
                exit 0
            elif [[ $REPLY =~ [^0-9] ]]; then
                select_regex
                exit 0
            elif [[ -n $line ]]; then
                selected="$line"
                break
            else
                printf "$p1" \
                       'Something is wrong!'
                back_trace
                exit 1
            fi
        done
        grep_line=$(grep -iF "$selected" <<< $arg1)
        if [[ ${FUNCNAME[@]} =~ youtube_search ]]; then
            play_youtube "$grep_line"
        else
            play "$grep_line"
        fi
        sleep 0.1 # needed for C-c
        exit 0
    fi
}

play_local() {
    local file
    local local_list=$(sed 's/^# //' "$LOCAL_MUSIC_PATH")
    if [[ -z ${g_arg[1]:-} ]]; then
        while true; do
            local_list=$(grep -v "$SKIP_PATTERN" <<< $local_list)
            shuffle_list "$local_list"
            (( $? == E_IN_A_ROW )) && continue
            play "$shuffle_radio"
            sleep 0.1 # needed for C-c
        done
    else
        local_list=
        for file in "$LOCAL_MUSIC_DIR"**/*; do
            if [[ $file =~ $LOCAL_MUSIC_EXT ]]; then
                local_list+="${local_list:+$'\n'}$file"
            fi
        done
        # test_print local_list
        make_namelist "$local_list"
        select_list "$local_list" "$input_lines"
    fi
    return 0
}

test_items() {
    local last_bg_pid
    local line
    testlist=$(grep . <<< $URL_LIST)
    cat > "$REPORT_PATH" <<< $REPORT_START_LINE
    while read -r line; do
        (( $(grep -c "$SKIP_PATTERN" <<< $line) )) && continue
        playing_print "$line"
        play $line &
        last_bg_pid=$!
        sleep $TEST_TIME
        if (( $(ps aux | grep -c $last_bg_pid) == 1 )); then
            echo "$line" >> "$REPORT_PATH"
        else
            kill $last_bg_pid
        fi
    done <<< $testlist
    printf '\n %s\n\n' \
           'REPORT:'
    cat "$REPORT_PATH"
    return 0
}

edit_this() {
    $EDITOR "$g_arg0"
    return 0
}

print_version() {
    printf '\n%s: %s\n\n' \
           "$SCRIPT_NAME" \
           "$SCRIPT_VERSION"
    return 0
}

help_usage() {
    cat <<EOF

Usage: radio [name] or radio option [arg ...]

radio
      - plays a shuffled radio, press 'q' to play the next.
        this loops infinitely, press Ctrl-c repeatedly to exit.

radio "regex"
      - plays a searched item.
        need quote for "or" regex searching like "wordA\|wordB".
        don't need quote for "and" regex searching, only need white-space.
        use -v for inverting match
        select items like 3-5 7 11 15-20, -2 6- ,  2  - 7  8
        search narrowly until only one chosen or all chosen
        press 00 to select all items
        ex) radio "sia\|live\|tv" cam "mango\|full"
            radio sia -v lsd : include "sia" but not "lsd"

Options:

-a | --all
      - displays all urls

-g | --group {en|kr|jp|mv|lt|ln|lc|pl}
      - plays a shuffled radio in a group, press 'q' to play the next.
        this loops infinitely, press Ctrl-c repeatedly to exit.
        ex) radio -g jp : play only the Japanese radio randomly

-l | --local ["regex"]
      - plays a shuffled local music.
        this loops infinitely, press Ctrl-c repeatedly to exit.
        ex) radio -l sia : play only local files with sia

-x | --xxx ["regex"]
      - plays a XXX for private
      - asks your password for bypassing a blocked site

-y | --youtube [option] [phrase]
      - searches a phrase in youtube and plays the urls
      - if no option and no phrase, display the cached phrases
      - use alias : alias yt='radio -y', then yt 'something'
      - options
        -d : delete the cached phrase
        -u : update the cached phrase
        -U : update all the cached phrases

-t | --test
      - tests all radios whether work or not.
        If failed, it logs on the file named report.

-e | --edit
      - edit this script.

-v | --version
      - prints this script version.

-h | --help
      - prints this help.

Exit Status:
Returns 0 unless an invalid option is supplied or an error occurs.

EOF
    return 0
}

bypass_site() {
    #
    # bypass for the blocked sites
    #
    if (( ! $(ps -A | grep -c notsodeep) )); then
        sudo iptables \
             -A INPUT \
             -p tcp \
             --tcp-flags SYN,ACK SYN,ACK \
             --sport 443 \
             -j NFQUEUE \
             --queue-num 200 \
             --queue-bypass
        sudo "$NOTSODEEP_PATH" &
    fi
    return 0
}

play_xxx() { # private
    bypass_site
    xxx_list=$(grep -v "$SKIP_PATTERN" "$XXX_PATH" \
                   | sed 's/^# //')
    if [[ -z ${g_arg[1]:-} ]]; then
        while true; do
            shuffle_list "$xxx_list"
            (( $? == E_IN_A_ROW )) && continue
            play "$shuffle_radio"
            sleep 0.1 # needed for C-c
        done
    else
        # test_print xxx_list
        make_namelist "$xxx_list"
        select_list "$xxx_list" "$input_lines"
    fi
    return 0
}

display_cached_phrases() {
    local p1="\n${C_40}%s phrase${C_}\n\n"
    local p2="\n${C_40}%s phrases${C_}\n\n"
    local p3="\n${C_220}%s\n${C_240}%s${C_}"
    local i=0
    local result_sort=$(printf '%s\n' "${!arr_result[@]}" | sort -f)
    readarray -t arr_result_sort <<< $result_sort
    for k in "${arr_result_sort[@]}"; do
        ((i++))
        if (( i > DISPLAY_C_PHRASE_LIMIT )); then
            c_phrase+=" | $k ..."
            break
        fi
        c_phrase+="${c_phrase:+ | }$k"
    done
    printf "$p3" \
           'the cached phrases' \
           "$c_phrase"
    case $i in
        0) printf "$p1" no;;
        1) printf "$p1" $i;;
        *) printf "$p2" $i;;
    esac
    exit 0
}

delete_cached_phrase() {
    #
    # -d delete the cached_phrase
    #
    local p1="\n${C_98}%s${C_}\n\n"
    local p2="\n${C_88}%s${C_}\n\n"
    local d_phrase="${g_arg[@]:2}"
    local d_matched
    local k
    for k in "${!arr_result[@]}"; do
        if [[ $k == $d_phrase ]]; then
            d_matched=1
            unset arr_result["$d_phrase"]
            #                ^^        ^
            # need $ and " "
            #
            declare -p arr_result > "$ARR_YOUTUBE_RESULT"
            source $BASH_COMPLETION_PATH
            break
        fi
    done
    case $d_matched in
        1) printf "$p1" "deleted with '$d_phrase'"     && exit 0;;
        *) printf "$p2" "not matched with '$d_phrase'" && exit 1;;
    esac
    return 0
}

update_cached_phrase() {
    #
    # -u update the cached_phrase
    #
    local last_search_date s_rate
    local k
    r_list=
    s_phrase="${g_arg[@]:2}"
    for k in "${!arr_result[@]}"; do
        if [[ $k == $s_phrase ]]; then
            r_list="${arr_result[$k]}"
            s_rate=$(head -n 1 <<< $r_list | cut -d ' ' -f 2)
            s_rate=$((s_rate+1))
            r_list=$(sed "1s/ [0-9]\+/ $s_rate/" <<< $r_list) # need 1s
            arr_result[$s_phrase]="$r_list"
            break
        fi
    done
    if [[ -n $r_list ]]; then
        get_result "$s_phrase"
        last_search_date=$(head -n 1 <<< $r_list | cut -d ' ' -f 1)
        input_lines=$(tail -n +2 <<< $r_list) # for select_list()
        PS3="
Last updated: $last_search_date
choose : "
        select_list "$input_lines" "$input_lines"
    else
        printf "$p1" \
               "not matched with '$s_phrase'"
        exit 1
    fi
    return 0
}

get_result() {
    if [[ ${FUNCNAME[1]} == update_cached_all ]]; then
        local -n _arg1="$1" # name reference
        readarray -t arg1 <<< $(printf '%s\n' "${!_arg1[@]}")
    else
        local arg1=( "$1" )
    fi
    local i=0 c=0
    local k l each
    local head_list dots
    local last_search_date search_count
    r_list= # need not local
    printf "\n${C_INFO_TITLE}%s | %s | %s${C_}\n\n" \
           "get_lists: $GET_LISTS" \
           "retry_after: $DUMP_RETRY_AFTER"s \
           "retry_limit: $RETRY_DUMP_LIMIT"
    for k in "${arg1[@]}"; do
        while [[ -z $result ]] ; do
            ((c++))
            if (( c > RETRY_DUMP_LIMIT )); then
                printf "$p1" \
                       'failed dumping, retry later!'
                exit $E_FAIL_DUMP_YOUTUBE
            fi
            ((i++))
            if (( c % 10 == 1)); then
                local p2="\r${C_117}%s\e[8m %s${C_}" # 8:hidden test
                printf "$p2" \
                       "($i/${#arg1[@]}) '$k' " \
                       ${dots:-.}
                dots=.
            else
                dots+=.
            fi
            printf "$p3" \
                   "($i/${#arg1[@]}) '$k' " \
                   $dots
            result=$(youtube-dl -j ytsearch$GET_LISTS:"$k")
            [[ -z $result ]] && sleep $DUMP_RETRY_AFTER && continue
            #
            # youtube-dl json_dump_keys:
            #
            # "id"            "uploader"           "uploader_id"
            # "uploader_url"  "channel_id"         "channel_url"
            # "upload_date"   "license"            "creator"
            # "title"         "alt_title"          "thumbnails"
            # "description"   "categories"         "tags"
            # "subtitles"     "automatic_captions" "duration"
            # "age_limit"     "annotations"        "chapters"
            # "webpage_url"   "view_count"         "like_count"
            # "dislike_count" "average_rating"     "formats"
            #
            # local g1='"title": ".*?", "formats": '
            # local g2='"upload_date": ".*?", "'
            # local g3='"duration": .*?, "view_count": '
            # local g4='"average_rating": .*?,'
            # local g5='"view_count": .*?,'
            # local g6='"uploader": ".*?", "'
            # local g7='"webpage_url": ".*?",'
            # local g8='"description": ".*?", "upload_date": '
            # r_title=$(grep -oP "$g1" <<< $result \
            #               | sed 's/, "formats": $//')
            # r_date=$(grep -oP "$g2" <<< $result \
            #              | sed 's/, "$//')
            # r_duration=$(grep -oP "$g3" <<< $result \
            #                  | sed 's/, "view_count": $//' \
            #                  | sed 's/\.0//') # workaround for 1234.0
            # r_rating=$(grep -oP "$g4" <<< $result \
            #                | sed 's/,$//')
            # r_count=$(grep -oP "$g5" <<< $result \
            #               | sed 's/,$//')
            # r_uploader=$(grep -oP "$g6" <<< $result \
            #                  | sed 's/, "$//')
            # r_url=$(grep -oP "$g7" <<< $result \
            #             | sed 's/,$//')
            # r_description=$(grep -oP "$g8" <<< $result \
            #                     | sed 's/, "upload_date": $//')
            #
            # jq is better than grep in json
            #
            r_title=$(jq '.title' <<< $result \
                          | sed 's/.*/"title": \0/')
            r_date=$(jq '.upload_date' <<< $result \
                         | sed 's/.*/"upload_date": \0/')
            r_duration=$(jq '.duration' <<< $result \
                             | sed 's/.*/"duration": \0/' \
                             | sed 's/\.0//') # workaround for 1234.0
            r_count=$(jq '.view_count' <<< $result \
                          | sed 's/.*/"view_count": \0/')
            r_rating=$(jq '.average_rating' <<< $result \
                           | sed 's/.*/"average_rating": \0/')
            r_uploader=$(jq '.uploader' <<< $result \
                             | sed 's/.*/"uploader": \0/')
            r_url=$(jq '.webpage_url' <<< $result \
                        | sed 's/.*/"webpage_url": \0/')
            r_description=$(jq '.description' <<< $result \
                                | sed 's/.*/"description": \0/')
            readarray -t arr_title <<< $r_title
            readarray -t arr_date <<< $r_date
            readarray -t arr_duration <<< $r_duration
            readarray -t arr_count <<< $r_count
            readarray -t arr_rating <<< $r_rating
            readarray -t arr_uploader <<< $r_uploader
            readarray -t arr_url <<< $r_url
            readarray -t arr_description <<< $r_description
            arr_total=( ${#arr_date[@]}        ${#arr_duration[@]}
                        ${#arr_count[@]}       ${#arr_rating[@]}
                        ${#arr_uploader[@]}    ${#arr_url[@]}
                        ${#arr_description[@]} )
            #
            # concisely check for parsing result
            #
            for each in ${arr_total[@]}; do
                # test_print each
                if (( ${#arr_title[@]} != each )); then
                    printf "\n\n${C_88}%s${C_}\n" \
                           'Not sync!'
                    printf "\n${C_240}%s\n${C_}" \
                           " ${FUNCNAME[0]} | $LINENO "
                    printf '\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n %s\n' \
                           "title       : ${#arr_title[@]}" \
                           "date        : ${#arr_date[@]}" \
                           "duration    : ${#arr_duration[@]}" \
                           "count       : ${#arr_count[@]}" \
                           "rating      : ${#arr_rating[@]}" \
                           "uploader    : ${#arr_uploader[@]}" \
                           "url         : ${#arr_url[@]}" \
                           "description : ${#arr_description[@]}"
                    sleep 1 # time to recognise this error
                    exit $E_NOT_SYNC_PROPERTIES
                fi
            done
            for l in ${!arr_title[@]}; do
                r_list+=$(printf "${r_list:+\n}%s %s %s %s %s %s %s %s" \
                                 "${arr_title[l]}" \
                                 "${arr_date[l]}" \
                                 "${arr_duration[l]}" \
                                 "${arr_count[l]}" \
                                 "${arr_rating[l]}" \
                                 "${arr_uploader[l]}" \
                                 "${arr_url[l]}" \
                                 "${arr_description[l]}")
                #                                   ^
                # $ can be removed for array index
                #
            done
            r_list=$(sort -t '"' -k 5 <<< $r_list)
            #                       ^
            # allow to add 3 extra " in title
            #
            last_search_date=$(date +%Y/%m/%d)
            if [[ $r_list =~ ^[0-9]{4}/[0-9]{2}/[0-9]{2} ]]; then
                search_count=$(cut -d ' ' -f 2 <<< $r_list)
            else
                search_count=1
            fi
            #
            # add last_search_date and search_count
            #
            head_list="$last_search_date $search_count"
            r_list=$(printf '%s\n%s' \
                            "$head_list" \
                            "$r_list")
            arr_result+=( ["$k"]="$r_list" ) # test
        done
        # reset vars for update_cached_all()
        if [[ ${FUNCNAME[1]} == update_cached_all ]]; then
            result=
            r_list= # need
            dots=
            c=0
            $PLAYER "$DUMP_SUCCESS_SOUND_PATH" &>/dev/null &
            printf " ${C_98}%s${C_}\n\n" \
                   "updated."
        fi
    done
    declare -p arr_result > "$ARR_YOUTUBE_RESULT"
    source "$BASH_COMPLETION_PATH"
    return 0 # end all update
}

update_cached_all() {
    #
    # -U update all the cached_phrase
    #
    # use for re-initializing cached list
    #
    get_result arr_result
    exit 0
}

invalid_youtube_option() {
    printf "\n %s${C_124} %s${C_} %s\n" \
           'There is no' \
           "'${g_arg[1]}'" \
           'option.'
    cat <<EOF

 Usage : radio -y option [ phrase ... ]

 Option: '' displays all cached phrases
         -d delete cached phrase
         -u update the cached phrase
         -U update all the cached phrases

EOF
exit 2
}

without_youtube_option() {
    local last_search_date s_rate
    local k
    for k in "${!arr_result[@]}"; do
        if [[ $k == $s_phrase ]]; then
            r_list="${arr_result[$k]}"
            s_rate=$(head -n 1 <<< $r_list | cut -d ' ' -f 2)
            s_rate=$((s_rate+1))
            r_list=$(sed "1s/ [0-9]\+/ $s_rate/" <<< $r_list)
            arr_result[$s_phrase]="$r_list"
            declare -p arr_result > "$ARR_YOUTUBE_RESULT"
            break
        fi
    done
    if [[ -z $r_list ]]; then
        get_result "$s_phrase"
    fi
    last_search_date=$(head -n 1 <<< $r_list | cut -d ' ' -f 1)
    input_lines=$(tail -n +2 <<< $r_list) # for select_list()
    PS3="
Last updated: $last_search_date
choose : "
    select_list "$input_lines" "$input_lines"
    return 0
}

youtube_search() {
    #
    # with youtube-dl --json-dump
    #
    local s_phrase="${g_arg[@]:1}"
    local GET_LISTS=50
    local DISPLAY_C_PHRASE_LIMIT=100
    local RETRY_DUMP_LIMIT=10
    local result=
    local r_list=
    local r_title r_date r_duration r_count
    local r_rating r_uploader r_url r_description
    local c_phrase s_rate
    local last_search_date
    local i=0 c=0
    local s1='s/.*" "upload_date": "\(.*\)" "uploader": .*/\1/'
    local g1='"title": ".*?", "formats": '
    local g2='"upload_date": ".*?", "'
    local g3='"duration": .*?, "view_count": '
    local g4='"average_rating": .*?,'
    local g5='"view_count": .*?,'
    local g6='"uploader": ".*?", "'
    local g7='"webpage_url": ".*?",'
    local g8='"description": ".*?", "upload_date": '
    local p1="\n ${C_88}%s${C_}\n\n"
    local p2="\r${C_117}%s${C_0} %s${C_}"
    local p3="\r${C_117}%s${C_40} %s${C_}"
    [[ -e $ARR_YOUTUBE_RESULT ]] && source "$ARR_YOUTUBE_RESULT" \
            || declare -A arr_result=()
    case ${g_arg[1]:-} in
        ''                ) display_cached_phrases ;;
        -d | --delete     ) delete_cached_phrase   ;;
        -u | --update     ) update_cached_phrase   ;;
        -U | --update_all ) update_cached_all      ;;
        -*                ) invalid_youtube_option ;;
        *                 ) without_youtube_option ;;
    esac
    return 0
}

invalid_other_options() {
    printf "\n %s${C_124} %s${C_} %s\n\n" \
           'There is no' \
           "'${g_arg[1]}'" \
           'option.'
    cat <<EOF

 Usage : radio -o option

 Option: -c display_color_code
         -C display_256color_code

EOF
    printf '\n'
    exit 2
}

without_other_options() {
    printf "\n %s${C_124} %s${C_}\n\n" \
           'There is nothing to do with' \
           "'${g_arg[1]}'"
    cat <<EOF

 Usage : radio -o option

 Option: -c display_color_code
         -C display_256color_code

EOF
    printf '\n'
    exit 2
}

other_options() {
    case ${g_arg[1]:-} in
        -c | --color_code    ) display_color_code    ;;
        -C | --256color_code ) display_256color_code ;;
        -*                   ) invalid_other_options ;;
        *                    ) without_other_options ;;
    esac
    return 0
}

invailed_option() {
    printf "\n %s${C_88} %s ${C_}%s\n" \
           'There is no' \
           "'${g_arg[0]}'" \
           'option.'
    cat <<EOF

 Usage : radio [name] or radio option [arg ...]

 Option: -a displays all urls
         -g {en|kr|jp|mv|lt|ln|lc|pl} plays a group
         -l ["regex"] plays a shuffled local music
         -x ["regex"] plays a XXX for private
         -y [option] [phrase] searches a phrase in youtube
         -o other options
         -t tests all radios
         -e edit this script
         -v prints version
         -h prints help

EOF
    return 0
}



#
# case uses * ? [...] | as matching pattern
#
# it doesn't use regex and variables basically
#
# if you need these, use regex condition: [[  =~  ]]
#
# set -x



case ${g_arg[0]:-} in
    ''             ) play_radio      && exit 0 ;;
    -a | --all     ) show_all        && exit 0 ;;
    -g | --group   ) play_group      && exit 0 ;;
    -l | --local   ) play_local      && exit 0 ;;
    -x | --xxx     ) play_xxx        && exit 0 ;;
    -y | --youtube ) youtube_search  && exit 0 ;;
    -o | --others  ) other_options   && exit 0 ;;
    -t | --test    ) test_items      && exit 0 ;;
    -e | --edit    ) edit_this       && exit 0 ;;
    -v | --version ) print_version   && exit 0 ;;
    -h | --help    ) help_usage      && exit 0 ;;
    -*             ) invailed_option && exit 2 ;;
esac
# set +x
make_namelist "$URL_LIST"
input_lines=$(grep -v "$SKIP_PATTERN" <<< $input_lines \
                  | sed 's/^# //')
# test_print input_lines
select_list "$URL_LIST" "$input_lines"

#  LocalWords:  dl ytsearch jq
