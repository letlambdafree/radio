#!/bin/bash

# radio - Bash shell script for listening radio basically

# Copyright 2020, Taeseong Ryu <formeu2s@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANT-ABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License at <http://www.gnu.org/licenses/> for
# more details.



### description:
#
# This script is for my personal purpose like playing music
# from various sources like radio, youtube, local storage.
# In 'select()', you can search narrowly, regex, range and default option.



### TODO
#
# curl, google code
# completion suggest for zsh
# visit the web-page playing youtube_search's result
# 1-1 loop
# select loop
# last selected item coloring



shopt -s globstar # Allow ** for recursive matches
set -u # avoid a undeclared variable
g_arg=( "$@" )
g_arg0="$0"
SCRIPT_VERSION=0.2.0
PS3='
# 00 for all
choose : '
PLAYER=mpv
LOCAL_VIDEO_DIR=/mnt/data/Videos/
LOCAL_MUSIC_DIR=/mnt/data/Music/
LOCAL_MUSIC_EXT='\.(mp3|flac)$'
SCRIPT_PATH=$(realpath "$g_arg0") # test
SCRIPT_DIR="${SCRIPT_PATH%/*}"
SCRIPT_NAME="${SCRIPT_PATH##*/}"
ARR_YOUTUBE_RESULT="$SCRIPT_DIR"/arr_youtube_result
ARR_YOUTUBE_SEARCH="$SCRIPT_DIR"/arr_youtube_search
ENGLISH_RADIO_PATH="$SCRIPT_DIR"/english_radio
KOREAN_RADIO_PATH="$SCRIPT_DIR"/korean_radio
JAPANESE_RADIO_PATH="$SCRIPT_DIR"/japanese_radio
LIVE_CAMERA_PATH="$SCRIPT_DIR"/live_camera
LIVE_NEWS_PATH="$SCRIPT_DIR"/live_news
LIVE_TV_PATH="$SCRIPT_DIR"/live_tv
LOCAL_MUSIC_PATH="$SCRIPT_DIR"/local_music
MUSIC_VIDEO_PATH="$SCRIPT_DIR"/music_video
PLAY_LIST_PATH="$SCRIPT_DIR"/play_list
XXX_PATH="$SCRIPT_DIR"/xxx # no public
RADIO_LIST=$(cat "$ENGLISH_RADIO_PATH" \
                 "$KOREAN_RADIO_PATH" \
                 "$JAPANESE_RADIO_PATH")
LIVE_LIST=$(cat "$LIVE_CAMERA_PATH" \
                "$LIVE_NEWS_PATH" \
                "$LIVE_TV_PATH")
URL_LIST=$(cat "$ENGLISH_RADIO_PATH" \
               "$KOREAN_RADIO_PATH" \
               "$JAPANESE_RADIO_PATH" \
               "$LIVE_CAMERA_PATH" \
               "$LIVE_NEWS_PATH" \
               "$LIVE_TV_PATH" \
               "$MUSIC_VIDEO_PATH" \
               "$PLAY_LIST_PATH" \
               "$XXX_PATH")
NOTSODEEP_PATH="$HOME"/git/notsodeep/notsodeep
yt_prefix='https://www.youtube.com/watch?v='
BASH_COMPLETION_PATH="$SCRIPT_DIR"/radio-completion.bash
REPORT_PATH="$SCRIPT_DIR"/report
REPORT_START_LINE='### ERROR REPORT'
TEST_TIME=10 # secs
PERIOD_TIME=600
DUMP_RETRY_AFTER=10
DUMP_SUCCESS_SOUND_PATH=/mnt/data/Sound/Alert.mp3
#
# basic regex escape ‘\?’, ‘\+’, ‘\|’, ‘\{’, '\}', ‘\(’, and ‘\)’
#
SKIP_PATTERN='^#\?$\|^##\+\|^#[^ ]\|^#  \+'
E_IN_A_ROW=64
E_NO_MATCH_REGEX=65
E_FAIL_DUMP_YOUTUBE=66
E_NO_PARAM=99



back_trace() {
    local max_length
    for key in ${!FUNCNAME[@]}; do
        if (( ${#FUNCNAME[$key]} > ${max_length:-0} )); then
            max_length=${#FUNCNAME[$key]}
        fi
    done
    # printf "\n %-${max_length}s : %5d" \
    #        LINENO $LINENO
    for key in ${!BASH_LINENO[@]}; do
        printf "\n %-${max_length}s : %5d" \
               ${FUNCNAME[$key]} \
               ${BASH_LINENO[$key]}
    done
    printf '\n'
}

test_print() {
    local arg1="$1"
    local arg2="$2"
    local items_number=0
    local p1='\n\e[1;38;5;40m%s item %s\e[0m\n'
    local p2='\n\e[1;38;5;40m%s items %s\e[0m\n'
    local p3='\n\e[1;38;5;220m%s %s\n\e[1;38;5;240m%s\e[0m'
    local caller_line_number=$(caller | cut -d ' ' -f 1) # test
    printf "$p3" \
           "${FUNCNAME[1]}()'s $arg1" \
           ":: $caller_line_number" \
           "$arg2"
    [[ -n $arg2 ]] && items_number=$(wc -l <<< $arg2)
    if (( $items_number == 1 )); then
        printf "$p1" $items_number
    elif (( $items_number > 1 )); then
        printf "$p2" $items_number
    else
        printf "$p1" no
    fi
    return 0
}

print_youtube_caches() {
    local arg1="$1"
    local arg2="$2"
    local arg3="$3"
    local p1='\n\e[1;38;5;40m%s item %s\e[0m\n'
    local p2='\n\e[1;38;5;40m%s items %s\e[0m\n'
    local p3='\n\e[1;38;5;220m%s\n\e[1;38;5;240m%s\e[0m'
    printf "$p3" \
           "${FUNCNAME[1]}()'s $arg1" \
           "$arg2"
    if (( $arg3 == 1 )); then
        printf "$p1" $arg3
    elif (( $arg3 > 1 )); then
        printf "$p2" $arg3
    else
        printf "$p1" no
    fi
    return 0
}

print_shuffle_list() {
    local arg1="$1"
    local p1='\n\e[1;38;5;220m%s\e[0m\n'
    local p2='\n\e[1;38;5;240m%s\e[0m\n'
    local p3='\n\e[1;38;5;196m%s\e[0m\n\n'
    local p4='\e[1;38;5;24m%s\e[0m'
    local p5='\e[1;38;5;25m%s\e[0m'
    local p6='\e[1;38;5;26m%s\e[0m'
    local p7='\e[1;38;5;27m%s\e[0m'
    local items_number=0
    printf "$p1" shuffle_list
    printf "$p2" \
           "$(printf %b "$arg1")" # need " " for printf and " " for arg1
    [[ -n $arg1 ]] && items_number=$(wc -l <<< $arg1)
    if (( $n_init_shuffle_list == 0 )); then
        printf "$p7" 'no item'
    elif (( $n_init_shuffle_list == 1 )); then
        printf "$p7" '1 item'
    elif (( $items_number == 1 )); then
        printf "\n${p7}${p6}${p5} ${p4}\n" \
               $items_number \
               '/' \
               $n_init_shuffle_list \
               'item'
    elif (( $items_number > 1 )); then
        printf "\n${p7}${p6}${p5} ${p4}\n" \
               $items_number \
               '/' \
               $n_init_shuffle_list \
               'items'
    else
        printf "$p3" ' Something is wrong!'
        back_trace
        exit 1
    fi
    return 0
}

playing_youtube_print() {
    local arg1="$1"
    local arg2="$2"
    local arg3="$3"
    local arg4="$4"
    local arg5="$5"
    local arg6="$6"
    local arg7="$7"
    local p1='\n\e[1;38;5;130m%s\e[0m\n'
    local p2="\n\e[1;38;5;142m%s | %s | %s | %.2f | %s\e[0m\n"
    local p3="\n\e[1;38;5;144m%s\e[0m\n\n"
    local IGNORE_DESCRIPTION_WORDS=3
    local DISPLAY_DESCRIPTION_LINES=10
    local arg5_h arg5_m arg5_s arg7_wc_w arg7_wc_l
    # test_print arg1 "$arg1"
    # test_print arg2 "$arg2"
    # test_print arg3 "$arg3"
    # test_print arg4 "$arg4"
    # test_print arg5 "$arg5"
    # test_print arg6 "$arg6"
    # test_print arg7 "$arg7"
    arg1=$(printf %b "$arg1")  # title
    arg2=$(date -d $arg2 +%Y/%m/%d) # date
    if (( $arg3 )); then # duration
        arg3_h=$((arg3/3600))
        arg3_m=$((arg3/60%60))
        arg3_s=$((arg3%60))
        if (( arg3_h )); then
            arg3=$(printf "%02d:%02d:%02d" \
                          $arg3_h \
                          $arg3_m \
                          $arg3_s)
        else
            arg3=$(printf "%02d:%02d" \
                          $arg3_m \
                          $arg3_s)
        fi
    else
        arg3=LIVE
    fi
    arg4=$(numfmt --to=si $arg4 | sed 's/G/B/') # count
    arg5=$(echo "$arg5 * 20" | bc) # rating
    arg6=$(printf %b "$arg6") # uploader
    arg7=$(printf %b "$arg7") # description
    printf "$p1" \
           "$arg1"
    printf "$p2" \
           "$arg2" \
           "$arg3" \
           "$arg4" \
           $arg5 \
           "$arg6"
    #
    # remove too short or too long description
    #
    arg7_wc_w=$(wc -w <<< $arg7)
    arg7_wc_l=$(wc -l <<< $arg7)
    if (( $arg7_wc_w >= $IGNORE_DESCRIPTION_WORDS )); then
        if (( arg7_wc_l > $DISPLAY_DESCRIPTION_LINES )); then
            arg7=$(head -n $DISPLAY_DESCRIPTION_LINES <<< $arg7)' ......'
        fi
        printf "$p3" \
               "$arg7"
    fi
    return 0
}

playing_print() {
    local arg1="$1"
    local p1='\n\e[1;38;5;130m %s\e[0m\n\n'
    # test_print arg1 "$arg1"
    if [[ $arg1 =~ https?:// ]]; then
        printf "$p1" "$(sed 's/http.*//' <<< $arg1)"
    elif [[ $arg1 =~ /$ ]]; then
        printf "$p1" "$arg1"
    elif [[ $arg1 =~ /mnt/ ]]; then
        printf "$p1" "$(sed 's!/mnt/.*!!' <<< $arg1)"
    else
        printf "$p1" "$arg1"
    fi
    return 0
}

make_namelist() {
    #
    # grep 'and' option
    #
    local arg1="$1"
    local reverse=
    declare -g input_lines=
    if [[ -n ${REPLY:-} ]]; then
        readarray -t arr_namelist <<< ${REPLY/ /$'\n'} # test
    else
        arr_namelist=( "${g_arg[@]}" ) # need " " like 'lsd sia'
    fi
    for line in "${arr_namelist[@]}"; do
        if [[ -z $input_lines ]]; then
            # test_print line1 "$line"
            [[ $line =~ ^-+[a-z]+ ]] && continue
            input_lines=$(grep -i "$line" <<< $arg1)
        else
            # test_print line2 "$line"
            if [[ $line == -v ]]; then
                reverse=v
                continue
            fi
            input_lines=$(grep -i$reverse "$line" <<< $input_lines)
            [[ -n $reverse ]] && reverse=
        fi
    done
    if [[ -z $input_lines ]]; then
        printf '\n \e[1;31m%s: \e[1;38;5;40m%s%s\e[0m\n\n' \
               'No match with regex' \
               $LINENO
        exit $E_NO_MATCH_REGEX

    fi
    return 0
}

make_shuffle_list() {
    local arg1="$1"
    local print_name print_names
    arg1=$(sed 's/^# //' <<< $arg1)
    readarray -t arr_arg1 <<< $arg1
    for line in "${arr_arg1[@]}"; do
        if [[ ${FUNCNAME[@]} =~ youtube_search ]]; then
            print_name=$(sed 's/.*"title": "//' <<< $line \
                                  | sed 's/" "webpage_url": ".*//')
        elif [[ $line =~  https?:// ]]; then
            print_name=$(sed 's/ http.*//' <<< $line)
        elif [[ $line =~ ^/mnt/ ]]; then
            print_name=$(sed 's!.*/Music/!!'<<< $line)
        elif [[ $line =~  /mnt/ ]]; then
            print_name=$(sed 's!/mnt/.*!!' <<< $line)
        else
            print_name="$line"
        fi
        print_names+=${print_names:+$'\n'}"$print_name"
    done
    print_shuffle_list "$print_names"
    return 0
}

shuffle_list() {
    #
    # all items must be selected only once for one-cycle
    #
    # uses shuf
    #
    local arg1="$1"
    local firstshuffle
    declare -g shuffle_list n_init_shuffle_list shuffle_radio last_shuffle
    # test_print arg1 "$arg1"
    [[ -z $arg1 ]] && exit $E_NO_PARAM
    if [[ -z ${shuffle_list:-} ]]; then
        n_init_shuffle_list=$(wc -l <<< $arg1)
        first_shuffle=$(shuf -n 1 <<< $arg1)
        #
        # avoid selecting the same item in a row
        #
        if [[ $first_shuffle == ${last_shuffle:-} ]]; then
            printf '\n \e[1;31m%s\e[0m\n\n' \
                   continue
            return $E_IN_A_ROW
        else
            make_shuffle_list "$arg1"
            shuffle_list=$(grep -vF "$first_shuffle" <<< $arg1) # needed -F
            shuffle_radio="$first_shuffle"
        fi
    else
        make_shuffle_list "$shuffle_list"
        last_shuffle=$(shuf -n 1 <<< $shuffle_list)
        shuffle_list=$(grep -vF "$last_shuffle" <<< $shuffle_list)
        shuffle_radio="$last_shuffle"
    fi
    # eval "$2=\$arg2" # bash special form for returning a string
    return 0
}

play_youtube() {
    local arg1="$1"
    local execute_part name_part
    local p_date p_average_rating p_view_count p_duration
    local p_title p_uploader p_description
    local s1 s2 s3 s4 s5 s6 s7 s8
    # test_print arg1 "$arg1"
    name_part=$(sed 's! "webpage_url": .*!!' <<< $arg1)
    # test_print name_part "$name_part"
    execute_part=$(sed 's!.* "webpage_url": !!' <<< $arg1)
    # test_print execute_part "$execute_part"
    s1='s/^\([0-9]\{8\}\) .*/\1/'
    s2='s/.* "duration": \([0-9]\+\) .*/\1/'
    s3='s/.* "view_count": \([0-9]\+\) .*/\1/'
    s4='s/.* "average_rating": \([0-9.]\+\) .*/\1/'
    s5='s/.* "title": "\(.*\)"$/\1/'
    s6='s/.* "uploader": "\(.*\)" "description": ".*/\1/'
    s7='s/.* "description": "\(.*\)"$/\1/'
    s8='s/^"\(.*\)" "uploader": ".*/\1/'
    p_date=$(sed "$s1" <<< $name_part)
    p_duration=$(sed "$s2" <<< $name_part)
    p_view_count=$(sed "$s3" <<< $name_part)
    p_average_rating=$(sed "$s4" <<< $name_part)
    p_title=$(sed "$s5" <<< $name_part)
    p_uploader=$(sed "$s6" <<< $execute_part)
    p_description=$(sed "$s7" <<< $execute_part)
    execute_part=$(sed "$s8" <<< $execute_part)
    # test_print p_date "$p_date"
    # test_print p_duration "$p_duration"
    # test_print p_view_count "$p_view_count"
    # test_print p_average_rating "$p_average_rating"
    # test_print p_title "$p_title"
    # test_print p_uploader "$p_uploader"
    # test_print p_description "$p_description"
    playing_youtube_print "$p_title" \
                          $p_date \
                          $p_duration \
                          $p_view_count \
                          $p_average_rating \
                          "$p_uploader" \
                          "$p_description"
    #
    # 1>/dev/null disable information
    # 2>/dev/null disable process-bar
    # &>/dev/null disable all
    #
    $PLAYER "$execute_part" 2>/dev/null
    return 0
}

play() {
    local arg1="$1"
    local execute_part name_part head_part option_part
    local p1='\n \e[1;31m%s\e[0m\n\n' \
    # test_print arg1 "$arg1"
    arg1=$(sed 's/^# / /' <<< $arg1)
    if [[ $arg1 =~  https?:// ]]; then
        name_part=$(sed 's! https\?://.*!!' <<< $arg1)
    elif [[ $arg1 =~ /$ ]]; then
        name_part="$arg1"
    elif [[ $arg1 =~ ^/mnt/ ]]; then
        name_part=$(sed 's!.*/Music/!!g' <<< $arg1)
    elif [[ $arg1 =~  /mnt/ ]]; then
        name_part=$(sed 's! /mnt/.*!!' <<< $arg1)
    else
        printf "$p1" \
               'Something is wrong!'
        back_trace
        exit 1
    fi
    # test_print name_part "$name_part"
    if [[ $arg1 =~  https?:// ]]; then
        execute_part=${arg1/*http/http}
    elif [[ $arg1 =~ /$ ]]; then
        execute_part="$LOCAL_MUSIC_DIR""$arg1"
    elif [[ $arg1 =~ ^/mnt/ ]]; then
        execute_part="$arg1"
    elif [[ $arg1 =~  /mnt/ ]]; then
        execute_part=${arg1/*mnt//mnt}
    else
        printf "$p1" \
               'Something is wrong!'
        back_trace
        exit 1
    fi
    #test_print execute_part "$execute_part"
    playing_print "$name_part"

    if [[ $execute_part =~  --[a-z]+ ]]; then
        head_part=${execute_part%% --*} # need space for trailing
        option_part=${execute_part#"$head_part" } # need quotes
        # test_print head_part $head_part"
        # test_print option_part "$option_part"
        $PLAYER "$head_part" $option_part # don't quote options
    else
        $PLAYER "$execute_part"
    fi
    return 0
}

play_radio() {
    while true; do
        radio_list=$(grep -v "$SKIP_PATTERN" <<< $RADIO_LIST)
        shuffle_list "$radio_list"
        (( $? == $E_IN_A_ROW )) && continue
        play "$shuffle_radio"
        sleep 0.1 # needed for C-c
    done
    return 0
}

show_all(){
    radio .
    return 0
}

play_group() {
    local group_list
    # test_print URL_LIST $URL_LIST
    case "${g_arg[1]}" in
        en | english    ) group_list=$(cat "$ENGLISH_RADIO_PATH");;
        kr | korean     ) group_list=$(cat "$KOREAN_RADIO_PATH");;
        jp | japanese   ) group_list=$(cat "$JAPANESE_RADIO_PATH");;
        mv | musicvideo ) group_list=$(cat "$MUSIC_VIDEO_PATH");;
        lt | livetv     ) group_list=$(cat "$LIVE_TV_PATH");;
        ln | livenews   ) group_list=$(cat "$LIVE_NEWS_PATH");;
        lc | livecam    ) group_list=$(cat "$LIVE_CAMERA_PATH");;
        pl | playlist   ) group_list=$(cat "$PLAY_LIST_PATH");;
        *)
            printf '\n %s\e[1;31m %s\e[0m %s\n' \
                   'There is no' \
                   "'${g_arg[1]}'" \
                   'group.'
            cat <<HEREDOC
 Usage : radio -g option
 Option: en - English Radio
         kr - Korean Radio
         jp - Japanese Radio
         mv - Music Video
         lt - Live TV
         ln - Live News
         lc - Live Camera
         pl - Play List
HEREDOC
            # back_trace
            exit 2
            ;;
    esac
    while true; do
        group_list=$(grep -v "$SKIP_PATTERN" <<< $group_list)
        shuffle_list "$group_list"
        (( $? == $E_IN_A_ROW )) && continue
        play "$shuffle_radio"
        sleep 0.1 # needed for C-c
    done
    return 0
}

select_one_input_line() {
    local names_count=$(wc -l <<< $input_lines)
    if (( $names_count > 1 )); then
        select_list "$arg1" "$input_lines" # select_list's arg1
    fi
    return 0
}

select_play() {
    local shuffle_line
    # test_print arg1 "$arg1" # arg1 is select_list()'s
    while true; do
        shuffle_list "$input_lines"
        (( $? == $E_IN_A_ROW )) && continue
        # test_print shuffle_radio "$shuffle_radio"
        shuffle_line=$(grep -iF "$shuffle_radio" <<< $arg1)
        if [[ ${FUNCNAME[@]} =~ youtube_search ]]; then
            play_youtube "$shuffle_line" # need
        else
            play "$shuffle_line"
        fi
        sleep 0.1 # needed for C-c
    done
    return 0
}

select_all() {
    printf '\n %s\n' \
           'You chose all items.'
    select_play
    return 0
}

select_sed() {
    local sed_reply
    printf '\n %s\n' \
           'You selected multiple items with - and numbers.'
    #
    # transform for sed
    #  3-5 7 11 15-20         --> 3,5p;7p;11p;15,20p
    #    3     -5  7  8-   9  --> 3,5p;7p;8,9p
    #   -  2     6  -         --> 1,2p;6,{endline}p
    #
    sed_reply=$(sed 's/^ \+\| \+$//g' <<< $REPLY \
                | sed 's/ \+/ /g' \
                | sed 's/ -\|- /-/g' \
                | sed 's/ /p;/g' \
                | sed 's/-/,/g' \
                | sed 's/^,/1,/' \
                | sed "s/,$/,$grepcount/" \
                | sed 's/$/p/')
    # test_print REPLY "$REPLY"
    input_lines=$(sed -n "$sed_reply" <<< $input_lines)
    select_one_input_line
    select_play
    return 0
}

select_regex() {
    printf '\n %s\n' \
           'You selected items with regex.'
    make_namelist "$input_lines"
    # test_print input_lines "$input_lines"
    select_one_input_line
    select_play
    return 0
}

select_list() {
    local arg1="$1"
    local arg2="$2"
    local r1='[0-9]*[-\ ]+[0-9]*'
    local r2='[^0-9\ -]+'
    local p1='\n \e[1;31m%s\e[0m\n\n'
    local input_name_part
    grepcount=$(grep -ic .  <<< $input_lines)
    if (( $grepcount == 1 )); then
        #
        # grep '-F' for only string like "[live] tv"
        #
        grep_line=$(grep -iF "$arg2" <<< $arg1)
        play "$grep_line"
        sleep 0.1 # needed for C-c
    elif (( $grepcount > 1 )); then
        if [[ ${FUNCNAME[@]} =~ youtube_search ]]; then
            #
            # "title" "도시의 그림자 -\n이 어둠의 이슬픔"
            # in select(), added one more line
            #
            input_name_part=$(sed 's/.* "title": "//' <<< $arg2 \
                                  | sed 's/" "webpage_url": ".*//' \
                                  | sed 's/\\n/ /')
            # test_print input_name_part "$input_name_part"
        elif [[ $arg2 =~  https?:// ]]; then
            input_name_part=$(sed 's! https\?://.*!!' <<< $arg2)
        elif [[ $arg2 =~ ^/mnt/ ]]; then
            input_name_part=$(sed 's!.*/Music/!!g' <<< $arg2)
        elif [[ $arg2 =~  /mnt/ ]]; then
            input_name_part=$(sed 's! /mnt/.*!!' <<< $arg2)
        elif [[ $arg2 =~  /$ ]]; then
            input_name_part="$arg2"
        else
            printf "$p1" \
                   'Something is wrong!'
            back_trace
            exit 1
        fi
        input_name_part=$(printf %b "$input_name_part") # Unicode-to-utf8
        # test_print input_name_part "$input_name_part"
        readarray -t arr_names <<< $input_name_part
        printf '\n' # needed
        select line in "${arr_names[@]}"; do
            if [[ $REPLY =~ ^00$ ]]; then
                select_all
                exit 0
            elif [[ $REPLY =~ $r1 && ! $REPLY =~ $r2 ]]; then
                select_sed
                exit 0
            elif [[ $REPLY =~ [^0-9] ]]; then
                select_regex
                exit 0
            elif [[ -n $line ]]; then
                selected="$line"
                break
            else
                printf "$p1" \
                       'Something is wrong!'
                back_trace
                exit 1
            fi
        done
        grep_line=$(grep -iF "$selected" <<< $arg1)
        if [[ ${FUNCNAME[@]} =~ youtube_search ]]; then
            play_youtube "$grep_line"
        else
            play "$grep_line"
        fi
        sleep 0.1 # needed for C-c
        exit 0
    fi
}

play_local() {
    local local_list
    local_list=$(cat "$LOCAL_MUSIC_PATH" \
                     | sed 's/^# //')
    if [[ -z ${g_arg[1]:-} ]]; then
        while true; do
            local_list=$(grep -v "$SKIP_PATTERN" <<< $local_list)
            shuffle_list "$local_list"
            (( $? == $E_IN_A_ROW )) && continue
            play "$shuffle_radio"
            sleep 0.1 # needed for C-c
        done
    else
        local_list=
        for file in "$LOCAL_MUSIC_DIR"**/*; do
            if [[ $file =~ $LOCAL_MUSIC_EXT ]]; then
                local_list+="${local_list:+$'\n'}$file"
            fi
        done
        # test_print local_list "$local_list"
        make_namelist "$local_list"
        select_list "$local_list" "$input_lines"
    fi
    return 0
}

test_items() {
    local last_bg_pid
    testlist=$(grep . <<< $URL_LIST)
    cat > "$REPORT_PATH" <<< $REPORT_START_LINE
    while read -r line; do
        (( $(grep -c "$SKIP_PATTERN" <<< $line) )) && continue
        playing_print "$line"
        play $line &
        last_bg_pid=$!
        sleep $TEST_TIME
        if (( $(ps aux | grep -c $last_bg_pid) == 1 )); then
            echo "$line" >> "$REPORT_PATH"
        else
            kill $last_bg_pid
        fi
    done <<< $testlist
    printf '\n %s\n\n%s\n\n' \
           'REPORT::'
           "$(cat $REPORT_PATH)"
    return 0
}

edit_this() {
    $EDITOR "$g_arg0"
    return 0
}

print_version() {
    printf '\n%s: %s\n' \
           "$SCRIPT_NAME" \
           "$SCRIPT_VERSION"
    test_print SCRIPT_NAME "$SCRIPT_NAME"
    return 0
}

help_usage() {
    cat << HEREDOC

Usage: radio [name] or radio option [arg ...]

radio
      - plays a shuffled radio, press 'q' to play the next.
        this loops infinitely, press Ctrl-c repeatedly to exit.

radio "regex"
      - plays a searched item.
        need quote for "or" regex searching like "wordA\|wordB".
        don't need quote for "and" regex searching, only need white-space.
        use -v for inverting match
        select items like 3-5 7 11 15-20, -2 6- ,  2  - 7  8
        search narrowly until only one chosen or all chosen
        press 00 to select all items
        ex) radio "sia\|live\|tv" cam "mango\|full"
            radio sia -v lsd : include "sia" but not "lsd"

Options:

-a | --all
      - displays all urls

-g | --group {en|kr|jp|mv|lt|ln|lc|pl}
      - plays a shuffled radio in a group, press 'q' to play the next.
        this loops infinitely, press Ctrl-c repeatedly to exit.
        ex) radio -g jp : play only the Japanese radio randomly

-l | --local ["regex"]
      - plays a shuffled local music.
        this loops infinitely, press Ctrl-c repeatedly to exit.
        ex) radio -l sia : play only local files with sia

-x | --xxx ["regex"]
      - plays a XXX for private
      - asks your password for bypassing a blocked site

-y | --youtube [option] [phrase]
      - searches a phrase in youtube and plays the urls
      - if no option and no phrase, display the cached phrases
      - use alias : alias yt='radio -y', then yt 'something'
      - options
        -d : delete the cached phrase
        -u : update the cached phrase
        -c : only search in the cached phrases

-t | --test
      - tests all radios whether work or not.
        If failed, it logs on the file named report.

-e | --edit
      - edit this script.

-h | --help
      - prints this help.

Exit Status:
Returns 0  unless an invalid option is supplied or an error occurs.

HEREDOC
    return 0
}

bypass_site() {
    #
    # bypass for the blocked sites
    #
    if (( ! $(ps -A | grep -c notsodeep) )); then
        sudo iptables \
             -A INPUT \
             -p tcp \
             --tcp-flags SYN,ACK SYN,ACK \
             --sport 443 \
             -j NFQUEUE \
             --queue-num 200 \
             --queue-bypass
        sudo "$NOTSODEEP_PATH" &
    fi
}

play_xxx() { # private
    bypass_site
    xxx_list=$(cat "$XXX_PATH" \
                  | grep -v "$SKIP_PATTERN" \
                  | sed 's/^# //')
    if [[ -z ${g_arg[1]:-} ]]; then
        while true; do
            shuffle_list "$xxx_list"
            (( $? == $E_IN_A_ROW )) && continue
            play "$shuffle_radio"
            sleep 0.1 # needed for C-c
        done
    else
        # test_print xxx_list "$xxx_list"
        make_namelist "$xxx_list"
        select_list "$xxx_list" "$input_lines"
    fi
    return 0
}

youtube_search() {
    #
    # uses youtube-dl's json-dump
    #
    local s_phrase="${g_arg[@]:1}"
    local s_limit=100 # it takes 8 secs to get 10 items, so need cache
    local max_cache=1000000
    local display_c_Phrase_limit=100 # modify later
    local retry_dump_limit=10
    local result=
    local r_list r_date r_duration r_count r_rating
    local r_title r_url r_uploader r_description
    local c_phrase s_rate d_phrase d_matched u_matched
    local last_date dots
    local p1='\n \e[1;31m%s\e[0m\n\n'
    local p2 p3 youtube_dl_opt
    local i=0 j=0 c=0
    if [[ -e $ARR_YOUTUBE_SEARCH ]]; then
        source "$ARR_YOUTUBE_SEARCH"
        source "$ARR_YOUTUBE_RESULT"
    else
        declare -A arr_search arr_result
    fi
    if [[ -z ${g_arg[1]:-} ]]; then
        for line in "${!arr_result[@]}"; do
            ((j++))
            if (( j > $display_c_Phrase_limit )); then
                c_phrase+="${c_phrase:+ }'$line' ..."
                break
            fi
            c_phrase+="${c_phrase:+ }'$line'"
        done
        print_youtube_caches c_phrase "$c_phrase" ${#arr_result[@]}
        exit 2
    elif [[ ${g_arg[1]} == -d ]]; then  # -d delete the cached_phrase
        d_phrase="${g_arg[@]:2}"
        for line in "${!arr_result[@]}"; do
            if [[ $line == $d_phrase ]]; then
                d_matched=1
                unset arr_result["$d_phrase"] # need $ and " "
                unset arr_search["$d_phrase"]
                declare -p arr_search > "$ARR_YOUTUBE_SEARCH"
                declare -p arr_result > "$ARR_YOUTUBE_RESULT"
                source $BASH_COMPLETION_PATH
                break
            fi
        done
        if (( $d_matched )); then
            printf "$p1" \
                   "success for deletion with '$d_phrase'"
            exit 0
        else
            printf "$p1" \
                   "not matched with '$d_phrase'"
            exit 1
        fi
    elif [[ ${g_arg[1]} == -c ]]; then  # -c search in the c_phrase
        s_phrase="${g_arg[@]:2}"
        for key in "${!arr_result[@]}"; do
            if [[ $key == $s_phrase ]]; then
                result="${arr_result[$key]}" # remove " "?
                s_rate=$((${arr_search[$s_phrase]}+1))
                arr_search[$s_phrase]=$s_rate
                break
            fi
        done
        if [[ -z $result ]]; then
            printf "$p1" \
                   'There is no cached_phrase.'
            exit 2
        fi
    elif [[ ${g_arg[1]} == -u ]]; then # -u update the cached_phrase
        s_phrase="${g_arg[@]:2}"
        for key in "${!arr_result[@]}"; do
            if [[ $key == $s_phrase ]]; then
                s_rate=$((${arr_search[$s_phrase]}+1))
                arr_search[$s_phrase]=$s_rate
                u_matched=1
                break
            fi
        done
        if (( ! $u_matched )); then
            printf "$p1" \
                   "not matched with '$update_phrase'"
            exit 1
        fi
    else
        for search in "${!arr_result[@]}"; do
            if [[ $search == $s_phrase ]]; then
                result="${arr_result[$search]}"
                s_rate=$((${arr_search[$s_phrase]}+1))
                arr_search[$s_phrase]=$s_rate
                break
            fi
        done
    fi
    if [[ -z $result ]]; then
        printf '\n'
        p2='\e[1;38;5;117m %s\e[0m %s\e[1;38;5;0m %s\e[0m\r'
        p3='\e[1;38;5;117m %s\e[0m %s\e[1;38;5;40m %s\e[0m\r'
        while [[ -z $result ]]; do # json-dump often fails
            ((c++))
            if (( $c > $retry_dump_limit )); then
                printf "$p1" \
                       'Fail dumping. Retry later!'
                exit $E_FAIL_DUMP_YOUTUBE

            fi
            if (( $c % 10 == 1)); then
                printf "$p2" \
                       "retry in ${DUMP_RETRY_AFTER}s"\
                       $c/$retry_dump_limit \
                       ${dots:-.}
                dots=.
            else
                dots+=.
            fi
            printf "$p3" \
                   "retry in ${DUMP_RETRY_AFTER}s"\
                   $c/$retry_dump_limit \
                   $dots
            youtube_dl_opt="-j ytsearch$s_limit:$s_phrase"
            result=$(youtube-dl -j "youtube-dl_opt" 2>/dev/null)
            sleep $DUMP_RETRY_AFTER # you can be banned for too many request
        done
        printf '\n'
        $PLAYER "$DUMP_SUCCESS_SOUND_PATH" &>/dev/null & # notice for success
        if (( ${#arr_result[@]} >= $max_cache )); then
            for key in "${!arr_search[@]}"; do
                if (( ${arr_search[$key]} <= ${min_rate:-10} )); then
                    min_rate=${arr_search[$key]}
                    min_key="$key"
                fi
            done
            unset arr_result["$min_key"]
            unset arr_search["$min_key"]
            printf '\n \e[1;31m%s - %s\e[0m\n' \
                   "'$min_key' has been removed" \
                   "$min_rate rated."
        fi
        arr_result+=( ["$s_phrase"]="$result" )
        if [[ -n ${arr_search[$s_phrase]} ]]; then
            arr_search+=( ["$s_phrase"]=${arr_search[$s_phrase]} )
        else
            arr_search+=( ["$s_phrase"]=1 )
        fi
    fi
    #
    # json_dump_key_order:
    #
    # "id" "uploader" "uploader_id" "uploader_url" "channel_id" "channel_url"
    # "upload_date" "license" "creator" "title" "alt_title" "thumbnails"
    # "description" "categories" "tags" "subtitles" "automatic_captions"
    # "duration" "age_limit" "annotations" "chapters" "webpage_url"
    # "view_count" "like_count" "dislike_count" "average_rating" "formats"
    #
    r_date=$(grep -oP '"upload_date": ".*?", "' <<< $result \
                 | sed 's/^"upload_date": "//' \
                 | sed 's/", "$//') # for sort
    r_duration=$(grep -oP '"duration": [0-9]+, "' <<< $result \
                   | sed 's/, "$//')
    r_rating=$(grep -oP '"average_rating": [0-9.]+, "' <<< $result \
                   | sed 's/, "$//')
    r_count=$(grep -oP '"view_count": [0-9]+, "' <<< $result \
                  | sed 's/, "$//')
    r_title=$(grep -oP '"title": ".*?", "' <<< $result \
                  | sed 's/, "$//')
    r_url=$(grep -oP '"webpage_url": ".*?", "' <<< $result \
                | sed 's/, "$//')
    r_uploader=$(grep -oP '"uploader": ".*?", "' <<< $result \
                     | sed 's/, "$//')
    r_description=$(grep -oP '"description": ".*?", "' <<< $result \
                        || grep -oP '"description": "", "' <<< $result)
    r_description=$(sed 's/, "$//' <<< $r_description)
    readarray -t arr_date <<< $r_date # first position
    readarray -t arr_duration <<< $r_duration
    readarray -t arr_count <<< $r_count
    readarray -t arr_rating <<< $r_rating
    readarray -t arr_title <<< $r_title
    readarray -t arr_url <<< $r_url
    readarray -t arr_uploader <<< $r_uploader
    readarray -t arr_description <<< $r_description # last position
    # test_print arr_date ${#arr_date[@]}
    # test_print arr_duration ${#arr_duration[@]}
    # test_print arr_count ${#arr_count[@]}
    # test_print arr_rating ${#arr_rating[@]}
    # test_print arr_title ${#arr_title[@]}
    # test_print arr_url ${#arr_url[@]}
    # test_print arr_uploader ${#arr_uploader[@]}
    # test_print arr_description ${#arr_description[@]}
    for title in "${arr_title[@]}"; do
        r_list+=$(printf "${r_list:+\n}%s %s %s %s %s %s %s %s" \
                         "${arr_date[i]}" \
                         "${arr_duration[i]}" \
                         "${arr_count[i]}" \
                         "${arr_rating[i]}" \
                         "${arr_title[i]}" \
                         "${arr_url[i]}" \
                         "${arr_uploader[i]}" \
                         "${arr_description[i]}") # $ can be removed
        ((i++))
    done
    r_list=$(sort <<< $r_list)
    last_date=$(tail -n 1 <<< $r_list | grep -o '[0-9]\{8\}')
    input_lines="$r_list" # for select_list()
    # test_print input_lines "$input_lines"
    if [[ ${g_arg[1]} != -c ]]; then
        declare -p arr_search > "$ARR_YOUTUBE_SEARCH"
        declare -p arr_result > "$ARR_YOUTUBE_RESULT"
        source $BASH_COMPLETION_PATH
    fi
    PS3="
Last uploaded: $last_date
choose : "
    select_list "$r_list" "$input_lines"
    return 0
}



#
# case uses * ? [...] | as matching pattern
# it doesn't use regex and variables basically
# if you need these, use regex condition: [[  =~  ]]
#
case "${g_arg[0]:-}" in
    ''             ) play_radio     && exit 0;;
    -a | --all     ) show_all       && exit 0;;
    -g | --group   ) play_group     && exit 0;;
    -l | --local   ) play_local     && exit 0;;
    -x | --xxx     ) play_xxx       && exit 0;;
    -y | --youtube ) youtube_search && exit 0;;
    -t | --test    ) test_items     && exit 0;;
    -e | --edit    ) edit_this      && exit 0;;
    -v | --version ) print_version  && exit 0;;
    -h | --help    ) help_usage     && exit 0;;
    -*)
        printf '\n %s\e[1;31m %s\e[0m %s\n' \
               'There is no' \
               "'${g_arg[0]}'" \
               'option.'
        cat <<HEREDOC
 Usage : radio [name] or radio option [arg ...]
 Option: -a displays all urls
         -g {en|kr|jp|mv|lt|ln|lc|pl} plays a group
         -l ["regex"] plays a shuffled local music.
         -x ["regex"] plays a XXX for private.
         -y [option] [phrase] searches a phrase in youtube
         -t tests all radios
         -e edit this script.
         -h prints version
         -h prints help
HEREDOC
        exit 2
        ;;
esac
make_namelist "$URL_LIST"
input_lines=$(grep -v "$SKIP_PATTERN" <<< $input_lines \
                  | sed 's/^# //')
# test_print input_lines "$input_lines"
select_list "$URL_LIST" "$input_lines"
